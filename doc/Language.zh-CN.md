# 前言(Foreword)

　　本文档是 Unilang 语言的设计规格说明。

## 体例说明

　　本文档中的特定文本（主要用于源代码）使用 `引用文本` 指定。非引用的正常文本适用以下体例。

　　局部的 *术语(terms)* 和 **强调** 的文本以特定的不同于其它正文的格式显示。

　　标记为 **注释** 的文本是*说明性(informative)* 的描述，而不是*正式(normative)* 规则。

　　标记为 **原理** 的文本是阐明语言设计*原理(rationale)* 的**注释**文本。

　　外部文档引用和内部章节引用以[超链接](https://zh.wikipedia.org/zh-cn/%E8%B6%85%E9%93%BE%E6%8E%A5)指定。全文外部引用另见以下的正式引用(normative references) 章节。

　　部分术语或其它名词性文本的特定义项首次出现时使用半角括号标注对应的英文翻译供参照。首字母缩略语(acronym) 和非局部概念的标题使用翻译时，词首字母大写。

　　本文档指定的语言规则(language rule) 中的形式文法(formal grammar) 包括形式语法(formal syntax) 和特定操作的形式，不提供附加的形式语义(formal semantic) 。

　　形式语法的语法类别(syntax category) 以 [BNF](https://zh.wikipedia.org/zh-cn/%E5%B7%B4%E7%A7%91%E6%96%AF%E8%8C%83%E5%BC%8F) 推导规则表示。

# 绪论(Introduction)

　　Unilang 是一门现代的、模块化的、可移植的和可扩展的通用目的编程语言。

　　Unilang 提供*基础语言(base language)* 和*语言扩展(language extension)* 。基础语言指定基本的语言规则；语言扩展在基础语言之上提供附加的规则，补充或改变语言的特定特性，提供比基础语言更多的实用功能。

**原理** Unilang 强调可扩展性，特别体现在语言特性可通过一个很小的语言核心上通过具有一定可移植性的用户编码的程序添加。基础语言的核心语言规则指定了这种核心的最小要求。一些实用的通用设施则一并以库的形式提供。原则上，一种特性被基础语言作为语言核心特性，仅当这种特性无法通过实现一种新语言规范以外的形式提供。这同时也是拒绝一些特性被核心语言明确支持的理由，特别是并不那么通用的特性——这些特性经常难以被移除而潜在地影响所有场景的所有用户；而通过库的方式，能允许以更灵活的方式可选地实现这些特性而减小矛盾。后者的一个典型例子是*垃圾回收(garbage collection, GC)* 。

## 范围(Scope)

　　本文档描述一个*符合(conforming)* *要求(requirements)* 的基础语言实现需要遵循的规则，这蕴含语言提供的*特性(feature)* 。这些语言特性主要是功能特性；其它的特性通常由语言的实现保证，而不影响*符合性(conformance)*。

　　在基础语言上附加语言扩展得到的*派生语言实现(derivative language implementation)* 可具有不同的语言规则，但应满足本文档中的最小要求以维持符合性。

　　派生语言实现是语言的设计，是抽象的实现。基础语言和派生语言实现都可能有非语言设计形式的具体实现（例如*解释器(interpreter)* ）。不致混淆时，派生语言实现简称*派生实现(derived implementation)* 。一般地，Unilang 语言的*实现(implementation)* 指非语言设计形式的具体实现以及基础语言的派生实现。

　　除非另行指定(specified otherwise) ，本文档的语言规则同时适用于基础语言和派生实现。

## 正式引用

　　本章引用本文档使用的外部参考(external reference) ，包含不被局部术语涵盖的一般解释。包括：

* ISO/IEC 2382 (all parts), Information technology — Vocabulary
* ISO/IEC 14882:2017, Information technology — Programming languages — C++
* [Fexprs as the basis of Lisp function application or $vau : the ultimate abstraction](http://www.wpi.edu/Pubs/ETD/Available/etd-090110-124904/unrestricted/jshutt.pdf) ([Shu10])
* [Revised<sup>-1</sup> Report on the
Kernel Programming Language](https://ftp.cs.wpi.edu/pub/techreports/pdf/05-07.pdf) ([RnRK])

　　对文献的引用以 [] 包含的形式标记。除以上列表中 () 备注的部分外，包括：

* [ISO C++] ISO/IEC 14882
* [ISO C] ISO/IEC 9899
* [ISO 2382] ISO/IEC 2382

**原理** Unilang 预期实现和 C++ 语言的实现能进行一定程度上的互操作；设计上，和 C++ 等语言也共享一些相似的基本概念。没有在本文档定义的术语可直接引用这些外部参考文献中的定义。[RnRK] 作为本文档中的一些 API 的参考设计来源，也在此一并列出。

# 术语和定义(Terms and Definitions)

* **行为(behavior)** 语言实现或在满足符合性的具体语言实现中的程序的外部表现。
* **程序(program)** 具体语言实现接受的以代码表示的输入，或被变换后对应的输出。
	* 语言实现支持运行*程序(program)* 。除非另行指定，程序指符合本文档要求的 Unilang 代码的输入程序，即 Unilang *源程序(source program)* 。
* **诊断(diagnostics)** 明确的对特定预期或非预期执行的行为的响应的总和。
* **诊断消息(diagnostic message)** 用于和用户交互的表现诊断的告知及提示。
* **未定义的(undefined)** 可能导致违反语言规范的约束但语言规范同时没有要求提供任何可能影响符合性的保证（如具有诊断消息）的。
	* **注释** 表示置于语言规则下的行为等不可预测。
* **未指定的(unspecified)** 规范隐式或显式地允许但不要求唯一确定的至少一个实现选项。
	* **注释** 通常允许多种不同的选项；但在特定实现配置下，规则中未指定的选项也可被限制为只有一种可行的选项。
	* **注释** 同一个实现或者不同实现可能确定地或非确定地选取不同的选项而不保证表现一致。

* **由实现定义的(implementation-defined)** 取决于各个具体语言实现的，要求有文档说明。
* **由派生实现定义的(derived-implementation-defined)** 取决于各个具体派生实现的，要求除存在默认定义或被派生实现的部分有明确的文档说明。
* **未定义行为(undefined behavior)** 未定义的行为。
* **未指定行为(unspecified behavior)** 未指定的行为，由实现选取规格中可能允许的指定行为的不确定选项，后者可能由显式或隐式的语言规则确定。
	* **注释** 推论：由实现定义的行为是未指定行为。
* **未指定行为(unspecified behavior)** ：未指定的行为。
	* **注释** 由实现选取规格中可能允许的指定行为的不确定选项，这些选项可能由显式或隐式的语言规则确定。
	* **注释** 推论：由实现定义的行为是未指定行为。在本文档中，为最小化依赖，不在正式规则中明确这些关系。

**注释** 一些术语和 [ISO C++] 类似，但在此显式定义。[ISO C++] 对 [ISO C] 具有类似的处理，但不尽相同。例如，ISO C 中由实现定义的行为是未指定行为（的子集），而 ISO C++ 中由实现定义的行为的定义不依赖未定义行为的定义，但逻辑上实质等价；而 ISO C 的未指定行为依赖*未指定值(unspecified value)* 的定义，但 ISO C++ 则依赖抽象机的选择动作直接定义未指定行为。在本文档中，为最小化依赖，不在正式规则中明确这些关系。

# 计算模型

　　本文档的 Unilang 语义规则以*抽象机(abstract machine)* 的形式提供。抽象机可具有*可变状态(mutable state)* 。

　　Unilang 程序的*执行(execution)* 可包括不同的*计算作用(computational effect)* ，包括：

* 确定一个作为计算结果的*值(value)* 。
* 改变抽象机中的可变状态。

　　后者称为*副作用(side effect)* ，包括：

* 特定的对象访问：改变抽象机中的可被程序*访问(access)* 的可变状态。
* *控制作用(control effect)* ：改变之后会被执行的程序。

**注释** Unilang 不是所谓的纯函数式语言，其中的计算允许描述状态的改变。表达式的求值的计算作用和 [ISO C] 以及 [ISO C++] 类似。不同的是，本文档的定义明确指定控制作用的更一般外延。特别地，最简单的条件分支也明确具有副作用。

**原理** 与一些简单认知不同，不限制计算蕴含副作用的上下文实际上不阻碍允许实现[引用透明性](http://www.itu.dk/people/sestoft/papers/SondergaardSestoft1990.pdf)。这也使理论模型（操作语义意义上）更加清晰一致并可直接扩展。例如，语义允许简单分支被表达为（派生实现定义的）异常控制流一并分析，而不需要首先假定分支总是被翻译为分支指令等内部表示形式才能应用 [SSA](https://en.wikipedia.org/wiki/Static_single_assignment_form) 等形式的中间表示。 

　　派生实现可定义其它的作用。

　　除非另行指定，副作用构成实现接受程序时具有的*可观察(observable) 行为*。

# 符合性(Conformance)

　　本文档指定 Unilang 程序的语言规则，包括语法和语义规则，以及实现环境应提供的程序接口。

　　Unilang 的实现翻译程序到适当的目标代码的形式。翻译的输入是源程序。翻译的直接输出可能是外部环境不可见的，即*解释(interpret)* ；也可以是确定具体形式的，即*编译(compile)* 。

　　一个符合本文档的实现应支持能接受符合规则的程序作为翻译的输入，并按本文档约定的规则中的要求表现计算作用影响的行为。

　　基础语言不要求实现蕴含不同的执行阶段。

**注释** 特定的程序是 *AOT(ahead-of-time)* 翻译的，翻译总在执行时的余下阶段之前进行，余下的阶段运行程序。基础语言是否使用 AOT 翻译实现未指定。因为一些动态特性，全局的 AOT 缺乏现实意义；实现仍可局部地替换局部的求值为多阶段翻译而允许相对直接解释更好的性能表现。

**原理** 除非实现新的语言，直接指定的多实现阶段不容易在基础语言中移除。而从没有指定多执行阶段的实现中添加阶段相对更容易实现。同时，这种方式能使用户自行替换多阶段翻译的实现，而不影响可移植性，获得比传统 AOT 编译器更好的适应性。

　　若程序具有未定义行为，则对实现没有任何要求，包括是否接受源程序的判定。

## 诊断(Diagnostics)

　　Unilang 要求具体实现对不满足语言规则约束的特定情形给出诊断。这类规则是*可诊断的(diagnostable)* 。

　　本文档中，*引起(signal)* 指定为*错误(error)* 的条件明确要求诊断。

　　违反语法规则的的情形是错误。

　　程序的语法性质和部分语义性质在翻译时检查，通过检查则应接受翻译，否则应提供诊断。

　　一次翻译接受的源代码是一个*翻译单元(translation unit)* 。对语法规则的检查以不大于翻译单元的单位整体进行。对未通过语法规则检查的诊断应至少能明确区分具体失败的翻译单元。

　　对象操作可能进行*检查(check)* 。检查失败引起错误。

## 最小符合性要求

　　Unilang 具体实现应满足以下最小符合性要求：

* 以翻译单元为单位进行翻译，满足：
	* 翻译接受*合式的(well-formed)* ，即符合语法规则和可诊断语义规则的程序。
	* 对*不合式的(ill-formed)* 程序，若不存在未定义行为，则要求翻译提供诊断消息并拒绝接受程序而终止程序的运行。（对 AOT 翻译实现，则直接终止翻译。）
* 对合式的程序，具体实现的行为符合抽象机语义蕴含的可观察行为。

　　注意可观察行为以外的具体实现行为和抽象机的行为的一致性未指定。这允许*优化的(optimimal)* 实现省略不影响可观察行为的计算作用。

# 词法规则(Lexical Rules)

　　Unilang 基础语言以空白符作为翻译单元中*词素(lexeme)* 的间隔。识别词素后，每个词素按照构成字符的不同，被分为不同的*记号(token)* 类别。

　　记号类别包含*标点(punctuator)* 、*字面量(literal)* 和*标识符(identifier)* 。

　　基础语言识别的标点包括 `(` 和 `)` 。

　　字面量包括：

* 以 `"` 作为词素起始和结尾的*字符串字面量(string literal)* 。
* 以 0~9 组成的十进制整数数值字面量。
* `#t` 和 `#f` 表示逻辑真和逻辑假。
* `#inert` 指定特定操作中表示被忽略的结果。

　　派生实现可在此之外定义其它记号类型和扩展的标点，后者应符合 C++ ([ISO C++]) 的定义。

　　派生实现也可定义*预处理(preprocessing)* 过程翻译其它表示为包含 Unilang 基础语言接受的词法形式的翻译单元。

# 语法

　　Unilang 基础语言的语法以基本语法和可通过前置预处理实现的*中缀变换(infix transformation)* 规则定义。

## 基本语法

```
<expression> ::= <atom-expression> | <composite-expression> | <list-expression>
<composite-expression> ::= <token-expression> | <expression-token>
<atom-expression> ::= <token>
<list-expression> ::= <left-list-bound> <expression>* <right-list-bound>
<left-list-bound> ::= `(` | <extended-left-list-bound>
<right-list-bound> ::= `)` | <extended-right-list-bound>
```

　　Unilang 基础语言的翻译单元以*表达式(expression)* 作为语法单位。一个表达式可以是：

* 不可拆分为其它表达式的*原子表达式(atom expression)* 。
* 由派生实现定义的，记号和其它表达式直接*并置连接(juxtaposition)* ，之间没有其它记号的表达式。
* 由分隔符作为边界的包含若干个*子表达式(subexpression)* 的*列表表达式(list expression)* 。

　　原子表达式在词法上是一个记号。

　　以下词法构造在基础语言中是空集，可由派生实现定义：

* `<extended-left-list-bound>`
* `<extended-right-list-bound>`
* `<token-expression>`
* `<expression-token>`

## 中缀变换

　　中缀变换替换形如 <expression> (<infix> <expression>)* 的记号序列为 <transformed-infix> <expression>+ 形式的记号序列。

　　其中，基础语言支持的中缀记号 <infix> 是 `;` 或 `,` ，而 <transformed-infix> 是语法不可见的中缀变换函数。

　　变换的不同 <expression> 的实例以相同的词法顺序在变换后的结果中被保存。

　　变换后的结果符合以上的基本语法规则。

# 语义

## 实体模型

　　Unilang 的程序操作*实体(entity)* 。

### 对象和值

　　区分*同一性(identity)* 的实体是*对象(object)*。同一性决定语言的不同表达式可以描述的相同的对象。

　　不区分同一性的特定的实体是*值(value)* 。

**注释** 同一性事实上表现了一般意义上的对象的[左值性](https://classes.cs.uoregon.edu/14S/cis607pl/Papers/fundamental-1967.pdf)。另见以下表达式的值和值类别的相关规则。

　　值可以具有*类型(type)* 以明确*外延(extension)*。

**注释** 类型一般建模为集合论意义上的*集合(set)* 。逻辑上，集合是类型的一种*释义(interpreation)* 。这种集合中的元素是可能作为类型*居留(inhabitant)* 的值。

### 可变性

　　对象可能具有*可变(mutable)* 状态，是可变的对象；对象也可能总是具有一种不被预言分辨的状态，是*不可变(immutable)* 的。其它实体是不可变的。

　　可变对象允许*改变(mutate)* 使对象具有不同的状态。

　　不可变对象仍允许指定内部的*可变管理状态(mutable administrative state)* ，以具有改变这些内部状态而不被视为对象整体上进行改变的操作。这类对象具有*内部可变性(interior mutability)* 。

**注释** 内部可变性的可变管理状态类似 [ISO C++] 的类的 `mutable` 数据成员表达的状态，因为它不影响 `const` 可修改性（在此视为可变性的一个实例）类型检查。

　　除非另行指定，对象上的所有操作都允许的不要求诊断错误的改变操作隐式地指定可变管理状态的改变。

　　语言实现可定义其它的机制明确同一性或外延的其它实体。

### 实体的类型

　　类型是一种值，其外延是类型*全集(universe)* 。

　　除非另行指定，不相同的类型的值之间不相等。

### 实体的值

　　对象总是关联特定*类型(type)* 的值作为它的内容，称为对象的值。

　　对象的值是对象的状态的一部分。对象的值的不可变性蕴含对象的不可变性，但反之不保证。这允许实现在对象中保存不影响值但仍可影响可观察行为的状态（例如同步需要的锁定状态）。

　　因为明确同一性，特定的对象实例总是可被*创建(create)* 或*销毁(destroy)* ，且可能影响可观察行为。

　　类似地，不明确同一性的一般实体可具有关联的值，但不保证作为其状态的一部分。

### 初始化

　　若实体关联值，初始化确定其的初始值。

　　创建对象时通过初始化确定对象的值。

　　初始化可使创建的对象作为其它对象的副本，这种初始化称为*复制初始化(copy initialization)* ；此时，其它对象的值不一定保持不变。其它实体的初始化称为*直接初始化(direct initalization)* 。

### 对象的存储期和生存期

　　程序执行时，对象占据存储资源，具有存储期。每个被创建后和销毁前的对象具有一段连续的*生存期(lifetime)* 。生存期是存储期的子集。

**注释** 这和 [ISO C++] 的对象的对应性质相同。

　　确定对象的值或改变对象的值访问对象。

　　在生存期外访问对象是受限的；除非另行指定，在生存期外访问对象的程序具有未定义行为。

### 内存安全

　　*内存安全(memory safety)* 是存储资源避免特定类型不可预测错误使用的性质。

　　基本的内存安全保证蕴含非并发访问时不引起未定义行为。这至少满足：

* 对对象占据的存储的访问总是在提供存储的对象的存储期内；
* 不访问对象的未被初始化的值。

　　特定的操作保证内存安全。

**注释** 内存安全不包含并发访问安全。当前语言不提供避免并发访问时可能具有数据竞争的机制。

**注释** 和宿主实现的互操作可能影响内存安全保证的实现。

**注释** 和许多语言的定义类似，内存安全不包含排除内存相关的*资源泄漏(resource leak)* 。但是，通过禁止[循环引用](#引用值和初始化)可避免一些原生引入的资源泄漏。

### 对象的所有权和子对象

　　一个或多个对象可具有另一个对象的*所有权(ownership)* ：前者约束后者的创建和销毁的时机。被所有的对象的生存期是所有者的生存期的并集的子集。

　　一个对象可以具有若干个*子对象(subobject)* ，在创建后创建子对象，在销毁前销毁子对象，而具有子对象的所有权。

　　类似地，对象可以对内部隐含的不以对象的方式可访问的资源实体具有所有权。

　　所有权作为实体上的二元关系，满足反自反、反对称和传递性。

### 对象的其它元数据

　　除以上性质外，对象可关联其它元数据以指定对象的属性种。不在语言中要求直接可被访问的实体统称为标签(tag) 。

　　对象具有的标签决定以下正交的性质：

* 唯一(unique) 引用：指定对象的值关联到自身以外的不被其它对象*别名(aliasing)* 的对象。以唯一引用关联的对象进行复制初始化时，不需要保留关联的对象的值。
* 不可修改(nonmodifying) ：指定对象的值保持不变（类似 [ISO C++] 的 `const` 类型的值）。若操作需要修改此对象，则引起错误。
* 临时(temporary) 对象：指定对象的值被临时使用。类似唯一引用，但限定的是对象自身而非关联的其它对象。

## 表达式的值和值类别

　　表达式通过*求值(evaluation)* 进行计算并体现计算作用，其中可确定表达式的计算结果作为关联的值，即表达式的值。

**注释** 关于求值的过程和相关规则，详见以下*求值算法(evaluation algorithm)* 中的描述。

　　在语法规则之上，基础语言约定可能*未求值的(unevaluated)* 表达式作为对象也具有值。未求值的表达式满足以下性质：

* 作为记号的标识符是*符号(symbol)* ，是符号类型的值。
* 列表表达式中若不含有子表达式，则这个表达式是空列表；否则，是非空列表。

　　空列表和非空列表统称列表，其中包含的子对象是列表的元素。未求值的非空列表中，子表达式是列表的元素。

　　Unilang 的列表是*真列表(proper list)* ：列表的元素有限，同一个列表的不同元素之间不具有相互的所有权，生存期不相交。

　　特定的值是*引用值(reference value)* ，具有引用类型。引用值关联到*被引用对象(referent)* 。引用值可以是唯一引用或引用临时对象的值，两者都是*右值引用(rvalue reference)* ；否则，引用值是左值引用。非引用值的唯一引用标签被忽略。

　　根据求值的结果表达的含义，表达式有以下基本分类：

* 泛左值(glvalue) ：求值用于决定被表示的对象的同一性的表达式；
* 纯右值(prvalue) ：求值不用于决定对象同一性（而仅用于初始化临时对象或计算对象中存储的值）的表达式。

　　一个泛左值可能被标记为*消亡值(xvalue)* 或作为临时对象的引用值，以提供基于不同的所有权的行为。

　　纯右值蕴含对象在可观察行为的意义上不被共享。

　　左值(lvalue) 是除了消亡值外的泛左值。右值(rvalue) 是消亡值或纯右值。

　　表达式不限定从源代码确定，且一个表达式的求值结果不排除继续构成表达式而被求值，因此表达式的值也普遍具有值类别。一等对象的值的类型和值类别存在以下一一对应关系：

* 若类型是引用，则对应的值类别是泛左值：
	* 若类型是左值引用，则对应的值类别是左值；
	* 若类型是右值引用，则对应的值类别是消亡值；
* 否则，对应的值类别是右值。

**注释** 和 ISO C++ 不同，Unilang 表达式，可能在程序运行时确定，由此确定的表达式的值类别不保证通过程序的静态构造直接确定。特别地，表达式可被求值为不一定具有相同值类别的其它表示，这种求值（如左值到右值转换）在 ISO C++ 中若和上下文相关，其中上下文能通过程序的静态构造确定，但在 Unilang 中则不一定。

　　引用类型和其它对象的类型不同。但除非另行指定，访问引用值总是等价于访问其被引用对象，这称为*左值到右值转换(lvalue-to-rvalue conversion)* 。例外而不进行这种转换的上下文中，引用值被*保留(preseved)* 。

**注释** 值类别、左值引用、右值引用及左值到右值转换和 [ISO C++] 的同名特性类似，后者实际上转换泛左值到右值。同 [ISO C++] ，左值到右值转换的左值也适用于泛左值。

　　除非另行指定，被求值的表达式的值类别是表达式求值结果的值类别。

**注释** 基于求值结果的值类别约定被求值的表达式的值类别是自然的，因为被求值的表达式自身的值类别通常不被关心（尽管在求值前，可构造表达式的副本以便用于其它求值，此时其值类别可能被关心）。这也和 ISO C++ 更加一致，尽管后者通过上下文（如 ISO C++ 的未求值操作数(unevaluated operand) ）就足够排除不同情形。但注意，表达式的值可能是左值，和右值不等价，这和 [ISO C] 的一般约定不一致。

　　具体表达式的值类别由本文档约定的求值算法和具体操作确定。

**注释** 临时对象类似 [ISO C++] 中延长对象生存期的引用，而唯一引用类似 [ISO C++] 中其它情形的右值引用。和 [ISO C++] 不同，引用值的被引用对象是一等对象，可能仍是引用值，这种转换的结果并非保证纯右值。唯一引用类似 [ISO C++] 的右值引用。

### 引用值和初始化

　　引用值可使用被引用对象作为初值进行直接初始化。

　　初值是引用值时，初始化的引用值的被引用对象可能是初值的被引用对象，这种情形称为*引用折叠(reference collapse)* 。其它情形初始化的引用值的被引用对象是初值。是否引用折叠依初始化发生的具体上下文而定。引用折叠的结果是唯一引用的一个必要条件是被引用对象是右值引用。

**注释** 引用折叠类似 [ISO C++] 的同名特性操作。但与 C++ 不同，引用值是一等对象，在某些保留引用值的实现相关的上下文中，被引用对象允许不发生引用折叠而直接使初始化的引用的被引用对象是引用值。

　　为支持引用值作为一等对象，在左值到右值转换的基础上定义更精细的引用值提升转换，即以下转换操作：

* 若操作数是引用值，则结果是操作数引用的被引用对象；
* 否则，结果是操作数。

**注释** 根据引用值的性质，若操作数是已被折叠的引用值，则引用值提升转换等价左值到右值转换；否则，有限次的引用值提升转换等价左值到右值转换。

　　程序在一些需要引用的被引用对象的上下文中使用返回值转换：一次引用值提升转换和可选的临时对象实质化转换的复合。

**注释** 实现可消除引用值而避免创建冗余对象的开销。

　　程序执行时引入循环引用的程序具有未定义行为。

　　临时对象可直接初始化引用值。和非临时对象的引用值不同，临时对象初始化的引用值和关联的被引用对象之间不需要区分同一性，因此使用被引用对象添加临时对象标签表示。

　　从纯右值初始化临时对象作为消亡值，称为*临时对象实质化转换(temporary materialization conversion)* 。

**注释** 这类似 [ISO C++] 引入临时对象的相同特性。

　　*可转移(movable)* 的对象通过以下规则确定：

* 非引用值的对象总是可转移的。
* 引用值关联的被引用对象可能是可转移的：
	* 若引用值具有的标签是被引用对象的唯一引用且非不可修改，被引用对象是可转移的。
	* 若引用值由临时对象初始化，被引用对象（即此临时对象）是可转移的。

　　若满足上述可转移对象条件的对象通过复制初始化创建对象副本，则对象被转移，被转移的对象的值在转移后未指定；否则，对象被复制，被复制的对象在复制后的值保持不变。

　　被转移后的对象具有*有效但未指定(valid but unspecified)* 的值。

**注释** 这和 [ISO C++] 相同。

## 变量和环境

　　*变量(variable)* 是具有*名称(name)* 的实体，参见 [ISO 2382]。

　　变量是在*环境(environment)* 对象中存储的*绑定(binding)* 的集合，即名称到实体的映射。被绑定的实体总是[一等对象](#一等实体)，称为*被绑定对象(bound object)* 。

　　环境对象对其中的被绑定对象具有所有权。

　　被绑定对象是环境的[可变管理状态](#可变性)。

　　语言中的环境以*环境引用(environment reference)* 的形式作为[一等对象](#一等实体)。环境对象自身在语言中不可见，必须通过环境引用访问。

**注释** 环境引用不是[引用值](#表达式的值和值类别)。后者关联的被引用对象是一等对象。

　　环境对象可能被环境共享。一个环境引用可能是*强引用(strong reference)* 或*弱引用(weak reference)* 之一。关联到相同的环境对象的环境强引用对关联的环境对象具有共享的[所有权](#对象的所有权和子对象)。

　　一个环境是*空环境(empty environment)* ，当且仅当其中的绑定是空集。

　　环境可以引用零个或有限多个*父环境(parent)* 。环境的父环境在创建时指定，之后不可变。

### 新环境

　　*新环境(fresh environment)* 是新创建的环境。除非另行指定，新环境是不存在能引起程序行为改变的父环境的空环境。

### 隐藏环境

　　语言实现可提供环境对象以外的非一等环境（详见以下一等实体的描述）。总是不能被对象语言以一等对象访问的环境是*隐藏环境(hidden environment)* 。

**注释** 一般地，隐藏环境是某一个（非隐藏的）一等环境的直接或间接父环境（而能通过求值等间接操作被访问）。

### 稳定性

　　环境在特定情形保证*稳定性(stability)* ：一个环境是*稳定的(stable)* ，仅当总是可假定绑定维持一定意义的等价性，而可确保访问其中同名实体的可观察行为等价。

**注释** 推论：稳定环境中的同名被绑定对象可证明排除通过对象的引用使其改变的副作用（如被修改）或总是具有同一性。

**原理** 从稳定的环境多次访问对象的计算作用是幂等的。这允许合并多次访问为一次而不改变程序的行为，允许具有较小的实现开销。

　　违反关于环境稳定性的要求的程序具有未定义行为。

**原理** 环境稳定性不易被可靠地判定甚至不可能被判定（例如，一个无法检查但可信的来源提供的环境），因此语言规则在此不要求进行检查。要求隐藏环境稳定允许实现共享隐藏环境作为父环境而提供标准环境。

　　任意[隐藏环境](#隐藏环境) `e` 应满足以下绑定有效稳定性：

　　通过引用值间接访问 `e` 中绑定的对象时绑定保持有效（蕴含不被移除或重绑定），保持被绑定对象的生存期和 `e` 对其的所有权。

　　任意隐藏环境的 `e` 的任意同一被绑定对象 `o` 应满足以下的值稳定性：

　　若 `o` 上发生使其改变的副作用（如被修改），则之后在以 `e` 或任意以 `e` 作为直接或间接父环境的环境中直接以名称解析或 `o` 的引用值访问 `o` 时，`o` 的值和发生作用前的 `o` 的值在影响可观察行为的意义上等价。

**注释**

　　以下情形发生的使对象其改变的副作用不受值稳定性要求的约束：

* 对象通过合并子调用的返回值或其中的子对象引用指定（不论合并子是否是隐藏环境中的子对象）；
* 对象通过间接访问具有内部可变性的对象的可变管理状态。

　　后者的一类典型实例是一等环境中的绑定中的子对象（即便这个一等环境对象是隐藏环境中的子对象）。

### 冻结

　　环境可被*冻结(freeze)* 。冻结后的环境中取得的绑定和引用值不可修改。

　　特定的环境修改要求环境不在冻结状态以确保不变量，要求类型检查。检查失败则引起类型错误。

　　冻结一个已被冻结的环境没有作用。

　　隐藏环境是冻结的。

　　语言不提供在已有环境撤销冻结的方法和在冻结的环境中添加、移除绑定或重绑定的方法。

### 名称解析

　　给定一个名称，在环境中确定被名称指称的对象，称为*名称解析(name resolution)* 。

　　基础语言使用以下名称解析算法：

1. 若在指定的环境中存在指定的名称对应的绑定，绑定的对象是名称查找的结果对象。
2. 否则，按创建环境时指定的顺序，深度优先搜索父环境中的绑定，搜索到的第一个确定对应的绑定的对象是名称查找的结果对象。
3. 否则，名称解析失败，引起错误。

　　成功的解析确定的对象以引用这个对象的引用值表示。

　　名称解析的深度优先搜索规则支持*词法作用域(lexical scoping)* 和*名称隐藏(name hiding)* 的实现。

　　求值 Unilang 表达式时总应存在一个环境，称为*当前环境(current environment)* ，作为名称解析算法的初始输入。

　　语言实现为程序开始运行时的具有的当前环境称为*初始环境(initial environment)* 。

　　部分名称是*保留名称(reserved name)* ：含有 `$$` 的名称保留给宿主交互使用；含有 `__` 的名称保留给语言实现。若程序的源代码中的保留名称被作为变量名解析，程序的行为未定义。

**注释** 隐藏环境作为父环境，可被名称解析利用，可以满足以其作为父环境的环境的稳定性。

## 间接值

　　引用值和环境引用统称间接值(indirect value) 。间接值关联和自身不同一的对象：引用值的被引用对象，和环境引用的环境对象。

　　间接值关联的对象通过间接值访问。

　　间接值有效当且仅当存在关联的对象且访问对象不引起未定义行为。其它间接值是无效的。

　　有效的引用值可能被*无效化(invalidate)* 。因关联的对象存储期结束而被无效化的是*悬空(dangling)* 间接值。

　　访问时，关联的对象的生存期未结束，否则非[内存安全](#内存安全)。

## 合并子

　　*合并子(combiner)* 是在特定表达式中出现的可被求值时*调用(invoke)* 的对象。

　　合并子的调用接受*操作数(operand)* 实体。一般地，操作数作为一个对象，可具有树型结构，即*操作数树(operand tree)* 。操作数树的子节点构成一个序列，其中每个子对象的值在调用时可作为*实际参数(actual argument)* ，进行计算。操作数可以是一个操作数树的子节点或连续的子节点序列。

　　合并子分为两类：

* 调用时总是先对操作数树中的每个直接子节点（即每个确定实际参数的操作数子对象）求值，然后调用对应的*底层(underlying)* 合并子。这种合并子是*应用合并子(applicative combiner)* 简称*应用子(applicative)* 。
* 否则，合并子是*操作合并子(operative combiner)* ，简称*操作子(operative)* 。

　　应用子的底层合并子可以是其它应用子，即确定实际参数的求值可能发生多次。

　　操作子调用匹配参数，可要求操作数符合一定的结构，否则参数不匹配。参数不匹配引起错误。

　　匹配参数后的操作子调用的具体行为由具体合并子对象确定。这可在创建合并子对象时决定。

　　合并子通过程序内的合并子的定义或其它另行指定的方式在外部引入。

　　在程序中定义的合并子提供指定*约束变量(bound variable)* 的*形式参数(parameter parameter)* 和指定确定变量后的其它作用的*求值结构(evaluation structure)* 。形式参数可以是符号、空列表及其复合的表达式树，统称为*形式参数树(formal parameter tree)* 。

　　一个存在形式参数的合并子被调用时，确定实际参数是否匹配形式参数树：确定实际参数和形式参数树中的对应位置的子表达式对应。若存在任一实际参数不对应，则参数不匹配。成功确定对应的形式参数树中的子表达式若为符号，则作为变量名，在特定的上下文中创建变量绑定，作为形式参数。绑定的实际参数和对应的形式参数作为不同的实体时，发生*参数传递(parameter passing)* 。参数传递使形式参数具有作为实际参数值的副本。参数传递可能使和实际参数相关的资源被复制或转移。

　　一个存在求值结构的合并子被调用、所有的参数都匹配成功且参数传递成功后，（参数传递确定的）形式参数的值替换求值结构中的副本中和形式参数树的子表达式相同的符号。

　　合并子的*正常(normal)* 调用总是可确定一个计算结果，作为求值的结果。除非另行指定，若求值结果为引用值，则*提升(lift)* 为被引用对象的值。这避免返回*悬空引用(danling reference)* 。

　　合并子的*非正常(abnormal)* 调用不确保调用结果。

　　非正常调用的控制被转移到需要调用的求值表达式之外，这可以发生在引起错误时。

　　关于合并子的形式理论，参见 [Shu10] 。

## 表达式语义

　　表达式符合的规则可能视使用的表达式，上下文相关。

### 求值算法

　　以被求值的表达式和所在的环境作为参数，基础语言使用以下统一的求值算法：

1. *自求值(self-evaluation)* ：若被求值的表达式不是符号或不是非空列表，则求值结果为自身。
2. 名称解析：若被求值的表达式是一个符号，则这个符号被视为*变量名(variable name)* ，求值结果为该符号在上下文（当前环境确定的词法作用域）中变量绑定确定的对象的经引用折叠的引用值。
3. 否则，被求值的表达式是一个非空列表，则：
	1. 若第一个子表达式是空表（这里不需要是字面上的语法表示 `()` ），则移除；
	2. 对第一个子表达式求值；
	3. 把第一个子表达式求值的结果作为*操作符(operator)* ，以其余子表达式作为操作数，求值*合并(combination)* 。

　　求值算法使用的环境是求值的*当前环境(current environment)* 。
　　
　　被作为操作符的值应是合并子右值或引用合并子对象的左值，求值合并的作用是调用对应的合并子；否则，求值失败，引起错误。

　　被求值的表达式的求值使用中缀变换和求值算法处理，实现求值。

**注释** 关于支持的中缀变换，详见以下相关小节。

### 中缀变换

　　中缀变换的 `<transformed-infix>` 在被求值时在操作符的位置，起到函数的作用。

　　以下中缀记号中缀变换函数的调用具有以下语义：

* `;` 求值同标准库函数 `$sequence` 。
* `,` 求值同标准库函数 `list%` 。

### 函数

　　成功调用合并子的表达式是*函数合并(function combination)* 表达式。在最终调用合并子的操作符位置的求值为合并子左值或右值的非列表表达式是*函数(function)* 。

　　函数是合并子右值、合并子左值（引用值）或求值为这些值的符号。

　　一般地，函数合并的求值结果替换函数合并表达式，这种替换是*函数调用(function call)* 。合并子调用的结果是函数调用的结果，称为*函数值(function value)* 。替换函数使操作数被求值的函数调用是*函数应用(function application)* 。

　　函数调用时，*主调函数(caller function)* 等*调用者(caller)* 或其它引起调用的计算的实体转移程序的控制到被调用的函数，使之*进入(enter)* 函数。控制可能通过调用被再次转移，即*嵌套调用(nested call)* 。一些被调用的过程可能被多次进入，即*重入(reenter)* 。

　　通过嵌套调用直接（总是以自身作为调用者）或间接（通过其它调用者转移控制）的重入是*递归调用(recursive call)* 。

　　特定的函数总是用来创建特定类型值的对象（右值）。这类函数是（特定类型值的）*构造器(constructor)* 。

### PTC(proper tail call)

　　求值函数调用时的最后一个函数调用是尾调用。尾调用发生在*尾上下文(tail context)* 。

**注释** 和某些其它语言不同，尾上下文是隐式的，由运行时的求值状态而非静态的语法构造确定。

　　若一个尾调用允许不限次数地重入，则尾调用是 PTC（Proper Tail Call，真尾调用）。

**注释** PTC 符合 [[Cl98]](https://www.researchgate.net/profile/William_Clinger/publication/2728133_Proper_Tail_Recursion_and_Space_Efficiency/links/02e7e53624927461c8000000/Proper-Tail-Recursion-and-Space-Efficiency.pdf) 中 proper tail recursion 的形式定义。

　　支持 PTC 的尾上下文中被求值的子表达式中的对象生存期可被调整，其方式未指定。

**注释** 这不影响可观察行为，但可能要求和其它语言的互操作遵循附加的要求。

　　以下上下文提供 PTC 支持：

* 求值算法中的操作合并的求值。
* 以下标准库中的求值：
	* 对 `<body>` 的求值；
	* 由 `<test>` 控制或连续求值多个表达式中最后被求值的子表达式求值。
	* 函数 `apply` 对 `<applicative>` 和 `<object>` 在 `<environment>` 或默认的动态环境中的应用。

　　不改变程序的可观察行为时，实现可支持任意其它的尾上下文上的 PTC 。

**原理** 缺乏核心语言特性支持下，难以通过库实现 PTC 保证。本质上，PTC 要求实现的结构在普遍配置下满足一定的空间复杂度要求，这不被基础语言（以及大部分其它现有编程语言）描述。使用库实现 PTC 要求反射并重写实现自身的结构，相当于重新实现具有 PTC 保证的新的语言；另一方面，从具有 PTC 保证的语言中通过库的特定操作消除 PTC（以允许资源清理和契约检查等操作占用尾调用的上下文）则相当容易。因此，PTC 保证原则上不适合通过库扩展，而应通过核心语言规则直接提供。

## 一等实体

　　程序引入或可被程序操作的 Unilang 实体在基础语言中是*一等实体(first-class entity)* 。一等实体总是可被作为操作数（用以调用函数）或作为函数调用的求值结果。

　　若一等实体是对象，它是*一等对象(first-class object)* 。

　　相较于其它语言，基础语言不附加限制区分非一等的实体。这有利于同时提升简单性和一致性。区分一等对象和一等实体并不是限制，

　　本文档和派生实现的语言规则可能引用其它的非一等对象。除非另行指定，不引入非一等对象。

　　在语言中可访问的环境一般是一等实体，即一等环境。语言也支持非一等的环境对象。访问非一等的环境对象时，它们不被环境对象的同一性影响，而是共享的。

**注释** 程序可在基础语言中指定不同的环境进行求值。但为可用性，环境的绑定和父环境这些状态都不是直接的一等实体。

　　临时对象非一等对象。

　　为灵活控制对象所有权，避免[循环引用](#引用值和初始化)且允许检查误用，一等环境可能对上述共享的资源实体具有所有权。大部分情况一等环境是共享环境状态的*弱引用(weak reference)* ，不具有所有权；其它情形一等环境对环境状态具有共享的所有权。

## 实体表示

　　除非另行指定，实体的值使用以下规则定义的*外部表示(external represetntation)* ：

* 对列表，输出的表示是以 `(` 和 `)` 作为边界，元素以单个 ` ` 为分隔符的序列，其中的元素被递归地嵌套输出。
* 对非列表的存在对应字面量的值，输出这个值的字面量形式。
* 对引用值，输出被引用对象。
* 其它值的外部表示未指定。

# 语言和程序接口约定

　　Unilang 实现环境应满足以上基础语言的语法和语义规则，并按以下的约定提供程序接口。

## 程序实现

　　语言实现外的程序是*用户程序(user program)* 。

　　以 Unilang 程序或派生语言实现指定的其它形式实现的可复用程序被归类为*库(library)* 。

　　语言特性包含不依赖库的*核心语言特性(core language feature)* 和*库特性(library feature)* 。本章之前的所有语言特性都是核心语言特性。

　　除非另行指定，一个 Unilang 程序支持多个库的实例，之间不共享内部的状态。

## 接口文法

　　描述语言规则和程序接口的元语言使用以下语法：

* `...` Kleene 星号，重复之前修饰的项 0 次或多次。
* `+`  重复之前修饰的项 1 次或多次。
* `?`  重复之前修饰的项 0 次或 1 次。

　　实体元素使用以 `<>` 包含的格式。注意基础语言中仍可出现同名的标识符，但此处不按标识符解释。

　　未求值的操作数：

* `<symbol>` ：符号。
* `<symbols>` ：元素为 `<symbol>` 的列表，形式为 `(<symbol>...)` 。
* `<eformal>` ：表示可选提供的环境名称或 `#ignore` 的符号。使用和 `<symbol>` 相同的表示。通常为动态环境。
* `<expression>` ：待求值的表达式。
* `<expressions>` ：形式为 `<expression>...` 的待求值形式。
	* 求值时被作为单一表达式，代替 `<expression>` 可避免语法中要求谁过多的括号及 `eval` 等求值形式中显式构造列表的需要。
* `<binding>` 绑定列表，形式为 `<symbol> <expressions>` ，用于指定被求值的表达式和绑定参数的符号。
* `<bindings>` ：元素为 `<binding>` 的列表，形式为 `(<binding>...)` 。
* `<body>`： 出现在元素的末尾 `<expressions>?` 形式，用于函数体等替换求值的目标。
* `<expression-sequence>` ：同 `<body>` 但蕴含顺序求值。
	* 求值 `<expression-sequence>` 的结果被定义为求值其最后一个子表达式（若存在）的结果，或当不存在子表达式时为 `#inert` 。
* `<consequent>` ：同 `<expression>` 仅用于 `<test>` 求值为 `#t` 时。
* `<alternate>` ：同 `<expression>` ，仅用于 `<test>` 求值不为 `#t` 时。
* `<definiend>` ：被绑定项的目标，是包含符号的有向无环图表达式。
* `<formals>` ：形式参数形式。同 `<definiend>` 但允许派生实现定义更多检查。
* `<clauses>` ：元素为条件分支的列表，形式为 `(<test> <body>)...` 。
* `<variable>` ：变量。用于表示被定义的名称。同 `<symbol>` ，其中的处理与作为非列表的 `<formals>` 相同。

　　求值得到的操作数：

* `<object>` ：一般对象，包括引用对象的引用值。
* `<reference>` ：对象引用值。
* `<list>` ：列表。
* `<lists>` ：元素都是列表的列表。
* `<bool>` ：布尔值，值为 `#t` 或 `#f` 的集合。
* `<test>` ：类似 `<object>` ，通常预期为 `<bool>` ，作为条件。当值非 `#f` 时条件成立。 
	* 若 `<test>` 求值为 `#f` ，则条件不成立。此时，若操作没有约定其它结果，则结果为 `#inert` 。
* `<combiner>` ：合并子。
* `<applicative>` ：应用子。
* `<predicate>` ：谓词，是应用操作数的求值结果的值为 `<test>` 的 `<applicative>` 。
* `<environment>` 一等环境。
* `<parent>` ：指定环境的父环境的值，包括 `<environment>` 或元素为 `<environment>` 的 `<list>` 。

　　操作数在操作的描述中作为约束。

　　为区分同类约束的不同项，约束的名称后（在 `>` 之前）的可带有以 1 起始的正整数序数。除非另行指定，这些序数仅用于区分不同的同类约束项，无其它附加含义。

　　求值得到的参数操作数约束隐含了操作接受的形式参数的值的类型。

　　函数可指定操作数的形式。对求值得到的参数，约束指定的操作数的类型，且实现应总是蕴含类型检查。类型检查失败时，引起错误。

　　库可以和本节相容的形式补充只在库中引用的操作数。除非另行指定，被作为约束使用的新引入的类型和其它类型都不同。

## 安全性

　　不同操作提供不同的安全保证，确保满足特定条件的使用不会引入未定义行为。

　　访问不保证有效的[间接值](#间接值)的操作是不安全[间接值](#间接值)访问。

　　语言提供关于[内存安全](#内存安全)的基本保证：不存在引起内存安全以外的未定义行为的操作且不存在不安全间接值访问时，程序执行保证内存安全。

**注释** 互操作可能不满足以上保证。

### 保留间接值

　　函数返回（在对象语言中允许出现的）间接值时，保留返回值的间接值。

　　函数在环境中绑定间接值或包含（在语言中允许出现的）间接值（如列表中以一等环境作为元素）作为子对象的对象时，保留环境的间接值。

　　函数返回包含间接值的对象由（在对象语言中允许出现的）参数决定时，保留参数的间接值。

　　保留返回值的间接值、环境的间接值或保留参数的间接值的函数保留间接值。

　　保留间接值作为返回值可能因间接值无效（如悬空引用）破坏内存安全。

　　保留环境的间接值时，应保证环境具有足够的生存期，以避免间接值依赖无效的环境引用（如引用值引用已不存在的关联环境导致访问环境中对象的未定义行为。

　　按被保留的间接值的来源，保留间接值分为以下两个子类：

* 直接保留间接值：接受间接值参数；
* 间接保留间接值：接受的参数或参数在特定环境中被求值得到的结果决定是否直接保留间接值。

　　引用值是一种间接值。因此，以上保留间接值的概念对应适用于间接值是引用值的情形。

### 接口的安全保证机制

　　对象语言接口的安全保证机制提供不同接口的分类，通过允许区分是否具有内存安全保证的接口帮助程序利用语言基本内存安全保证。

　　除非另行指定，保留的引用值被引用折叠。

**注释** 通过要求引用折叠，可保证不引入引用的引用。

　　部分操作总是返回非引用值，以满足具体操作的语义要求，减少误用的可能性，并帮助提供内存安全保证。

　　返回非引用值的行为等价蕴含[返回值转换](#引用值和初始化)：若按其它规则返回的值是引用值，则实际返回这个引用值关联的被引用对象。这可约束作为间接值的引用值不逃逸(escape)（即使用被引用对象的值时不超出指向对象的生存期），而保证只考虑返回值可能是引用值时的内存安全。

　　其它操作可返回引用值。是否保留引用值按以下的[操作名称约定](#操作名称约定)的函数命名规则确定。

　　[间接保留引用值](#保留间接值)可包含部分直接[转发](#操作数约定)引用值的情形。包含这种情形的操作不因此被视为直接保留引用值，即便部分引用通过直接转发引用值被保留。这保证以上两个子类不相交。

　　[直接保留引用值](#保留间接值)覆盖常规函数约定的实际参数约定，指定参数不隐含[左值到右值转换](#引用值和初始化)，可按引用值直接访问。

# 基础语言实现环境

　　Unilang 以环境的绑定作为公开的接口提供库特性。

　　基础语言提供一个*基础环境(ground environment)* ，其中蕴含的变量绑定（包括包含的变量绑定和可能通过环境子对象提供的变量绑定）提供上述的主要的特性，作为程序应用程序的编程接口，也是语言扩展和应用程序的可编程性的基础。基础环境应包含语言规范要求提供的所有绑定，且不包含名称除保留名称外的绑定。

　　基础语言的用户程序初始的当前环境是一个包含基础环境作为直接或间接父环境的空环境。基础环境在此是[隐藏环境](#隐藏环境)，应能确保程序执行时[不改变基础环境中的绑定](#冻结)。

**注释** 为此，基础环境自身不是以一等环境提供的库特性，而是核心语言特性。

　　实现在用户程序初始的当前环境中按本文档指定的方式继续提供绑定，以便简化公共实现。

　　基础环境的绑定提供的特性有两类：对象和*操作(operation)* 。应被支持的操作以具有明确名称的函数进行指定，参见以下章节。

　　库特性按分为*基本的(primitive)* 和*派生的(derived)* 。前者在设计上不分解为更小的其它特性的组合；后者可由基础语言代码实现。本文档中不明确指定派生的特性是否使用以基础语言源程序进行派生的形式实现。

　　本文档中约定的在基础环境中的特性中，以库提供的总称为*标准库(standard library)* 。本文档中的库特性都是标准库特性。

## 模块

　　以绑定提供的语言特性被分组归类为*模块(module)* 。

　　模块的*源(source)* 提供特性的实现。

　　因为模块以绑定的集合的形式提供，需被包含在可访问的环境，或包含环境作为子对象的其它对象中。

　　从模块的源得到提供一个模块的所有绑定集合的环境对象的过程称为模块的*加载(loading)* 。

　　模块加载可能失败。失败的模块加载引起错误。

　　标准库模块的加载失败不被直接依赖这些环境的用户程序处理（而视为实现初始化的运行时错误）。

　　一般地，模块和加载模块得到的环境对象没有直接对应关系：一个模块的绑定可以由一个或多个环境提供，一个已被加载的环境可能提供零个或多个程序可见的模块。但除非另行指定，一个模块的绑定不在超过一个的不相交的环境（之间没有直接或间接父环境关系）中提供。

　　程序可通过加载外部模块来源取得模块。除非另行指定，这种模块以一个一等环境对象（可包含作为环境的直接或间接子对象）中的绑定提供。

　　标准库包括以下模块：

* 标准库基本对象和操作。
* *核心库(core library)* ：提供直接绑定在基础环境中的派生操作的标准库子集。
* 标准库扩展模块：在标准库中提供环境的绑定，并在其中提供库的接口。
* 在基础环境中提供的辅助库接口。

**注释** 辅助库接口在当前标准库内未归类，可能迁移或移除。

　　除绑定可能在不同环境直接提供外，不同模块的边界不被要求在基础语言的实现中区分。

　　派生实现可以库的形式提供语言扩展或其它功能特性，扩充标准库。

　　以下各节的约定对标准库函数有效，用户程序不被要求。

## 操作名称约定

　　对应合并子是操作子的函数以 `$` 起始。

　　作为谓词的函数名以 `?` 结尾。

　　为改变对象而直接（而不是通过指定参数求值）蕴含副作用函数名以 `!` 结尾。

　　若函数提供结果无条件保留引用值和不保留引用值的不同版本且保留引用值的函数是不安全函数，保留引用值的函数名以 `%` 作为（在可能的 `!` 之前的）后缀。

**原理** 关于 `$`、`?` 和 `!` 的原理，参见 [RnRK] 1.3.7 。

## 不安全操作

　　不安全(unsafe) 操作是可能在程序的执行中引入未定义行为的操作。

　　这里的未定义行为包含在操作中直接引入的未定义行为，以及因为操作被执行而使程序在之后无法确保排除的未定义行为。

　　不安全操作是实现可选提供的。这些操作可能因不同理由在操作中或操作之后的程序中引入未定义行为：

* 保留可能无效的间接值：
	* 保留可能无效的引用值（如[悬空引用](#中间值)）。
	* 保留可能无效的环境引用。
* 可能因为操作环境强引用而引入循环引用。
* 可能引入数据竞争。
* 是其它另行指定的可能引入未定义行为的操作。

**注释** 当前语言不支持并发访问对象。数据竞争仅可由和宿主语言的互操作引入。

　　通过避免或限制使用具体的不安全操作，可实现上述安全保证。

　　除非另行指定，执行时包含以下操作的操作是不安全操作：

* 以下不具有内存安全保证的操作：
	以下相关章节按[操作名称约定](#操作名称约定)的保留引用值的操作。
	其它保留间接值的操作。
* 以下可能引入[循环引用](#引用值和初始化)的操作：
	引入引用现有环境的环境强引用的操作。
* 其它另行指定的操作。

**注释** 互操作可包含和以上操作等效的不安全操作。

## 操作数约定

　　一些求值为引用值的函数实际参数被保留，而不进行[左值到右值转换](#引用值和初始化)。这些值以保留值类别不变的形式被直接作为操作数，用于调用其它合并子。这种参数被*转发(forward)* 。

**注释** 参数转发类似 [ISO C++] 的 `auto&&` 推导的参数值的转发。

## 操作结果约定

　　若以下关于操作的描述中未指定调用的求值结果，则结果为右值 `#inert` 。

　　除非另行指定，没有明确在操作结果中保留引用值的其它一些操作的结果进行返回值转换：一次引用值提升转换和可选的临时对象实质化转换的复合。

　　若函数是用于返回非引用值的*构造器(constructor)* ，则可能提供不同的变体：

* 实际参数发生左值到右值转换。这减少悬空引用的可能性。
* 实际参数不发生左值到右值转换。这是不安全操作，但可以确保构造的对象中包含参数指定的引用值。

### 保留引用值的操作子

　　部分函数是选取特定实际参数求值用以确定结果的操作子。这类操作子结果直接是求值的参数，保留引用值而不进一步转换。

# 标准库接口

　　本章指定标准库提供的具体程序接口。

## 标准库对象

　　标准库的对象在基础环境中直接提供绑定。

　　标准库提供对象 `ignore` ，其值为符号 `#ignore` ，在特定操作中表示被忽略的值。

## 标准库基本操作

　　标准库基本操作在基础环境中直接提供绑定。

`eq? <object1> <object2>`

　　判断引用相等关系。当且仅当对象同一时引用相等。

`eqv? <object1> <object2>`

　　判断非列表的值相等关系。当且对象转换的右值相等时比较结果为 `#t` 。比较列表对象是否相等未指定。

`$if <test> <consequent> <alternate>`

　　条件分支，按条件成立与否返回 `<consequent>` 或 `<alternative>` 之一，可能是引用值。

`$if <test> <consequent>`

　　省略第三操作数的条件分支，条件成立时返回 `<consequent>` 。

`null? <object>`

　　判断操作数是否为空列表。

`bound-lvalue? <object>`

　　判断操作数是否为被引用的被绑定对象左值。

**注释** 绑定临时对象的引用类型的参数不被视为左值引用。

`uncollapsed? <object>`

　　判断操作数是否为未折叠的引用值。

`as-const <object>`

　　取指定对象的不可修改的引用。

　　当参数是引用值时，结果是和参数引用相同对象的不可修改的引用值；否则，结果是参数。

`expire <object>`

　　取指定对象的唯一引用。

　　当参数是引用值时，结果是和参数引用相同对象的唯一引用值；否则，结果是参数。

`move! <object>`

　　转移对象。

　　若参数是不可修改的左值，则以复制代替转移；否则，直接转移参数对象。

　　结果是不经返回值转换的项。

`assign@! <reference> <object>`

　　赋值被引用的对象为指定对象的值，且 `<object>` 不隐含左值到右值转换且不被折叠。

　　检查 `<reference>` 是可修改的左值。

　　赋值对象直接修改被引用的对象，但不无效化参数指定的引用。

`cons <object> <list>`

　　构造两个元素的列表。

　　因为不支持列表中存在环，因此第二个操作数应为列表，否则引起错误。

`cons% <object> <list>`

　　构造两个元素的列表，保留引用值。

　　同 `cons%` ，但 `<object>` 是引用值时，直接以其值作为列表元素的值，而不以其被引用对象的值作为列表元素的值。

`desigil <symbol>`

　　移除符号中的引用标记字符 `&` 或 `%` 。

　　判断符号非空且以 `&` 或 `%` 起始，结果为移除起始字符的参数。否则，结果为参数。

　　不处理引用标记字符 `@` 。

`eval <expression> <environment>`

　　在参数指定的环境中求值，结果作为函数值。

`eval% <expression> <environment>`

　　同 `eval` ，但保留引用值。

`bound? <string>`

　　判断指定字符串对应的符号是否被绑定。

`$resolve-identifier <symbol>`

　　解析标识符。

　　直接保留解析结果中项的类型，不按成员访问规则确定值类别，因此和解析名称表达式的结果总是左值不同，可保留消亡值。

`$move-resolved! <symbol>`

　　转移解析标识符的对象。

　　和 `$resolve-identifier` 类似，但直接取被绑定的对象并从环境中转移。

**注释** 一般应仅用于被绑定的对象不需要再被使用时。

`lock-environment <environment>`

　　锁定环境：创建环境强引用。

　　检查操作数的环境弱引用，结果为对应的环境强引用。

**注释** 强引用可能引起环境之间的不被检查的[循环引用](#引用值和初始化)，用户应自行避免未定义行为。

`make-environment <environment>...`

　　创建以参数为父环境的环境。

　　创建的环境是强引用。

`$def! <definiend> <expressions>`

　　修改当前环境中的绑定。

　　类似 <formals> ，<definiend> 支持递归匹配。

`$vau/e <parent> <formals> <eformal> <body>`

　　创建指定静态环境的 vau 抽象。

**原理** 关于 vau 抽象，参见 [Shu10] 。[RnRK] 提供和本文档中的 vau 抽象构造器类似的操作，但不包含 `<parent>` 的支持。

　　创建的抽象是操作子，作为求值 `$vau/e` 的调用结果。

　　求值 `$vau/e` 的调用首先求值 `<parent>` ，其结果中的环境是创建的抽象的*静态环境(static environment)* 。

　　`<formals>` 是指定*形式参数(formal parameter)* 表达式，应为以符号为非分支节点的有向无环图。由于不支持引用值，实际上是树，非分支节点是树的叶节点，分支节点是列表。

　　`<eformal>` 是指定*动态环境(dynamic environment)* 的表达式，应为符号。动态环境是发生调用处的当前环境。

　　`<formals>` 被用于在合并子调用时匹配操作数树，参数匹配算法如下：

* 初始化 <formals> 为当前形式参数，函数合并（包括作为合并子的第一个子项和作为操作数的之后余下的子项）作为当前操作数。
* 对每一对当前形式参数和当前操作数，比较两者（除非另行指定，操作数的值是引用值的，视为匹配被引用对象，下同）：
	* 若两者都是列表，则：
		* 若形式参数列表元素的末尾元素不是符号也不是列表，则参数匹配失败。
		* 若形式参数列表元素的末尾元素是以 `.` 起始的符号，则存在*省略(ellipsis)* ；保存移除 `.` 的符号，并从子项中移除末尾元素，继续进行比较。
		* 若形式参数和操作数的（直接）子节点数（作为实际参数时的列表元素数）相等，或存在省略时移除末尾元素后的形式参数元素数不大于操作数子节点的元素数，则：
			* 除被保存的省略的元素外，以深度优先搜索从左到右逐一递归匹配两者的元素。
			* 对省略的元素，若保存移除 `.` 的符号非空，创建一个列表对象保存匹配的操作数中的零个或多个对象，绑定到以保存的符号作为名称的变量。
			* 否则，所在的形式参数列表的末尾元素是 `.` ，忽略操作数，不绑定对象。
		* 否则，若不存在省略，列表的元素数不相等，参数匹配失败。
		* 否则，操作数的子节点不足，参数匹配失败。
	* 若形式参数不是符号，则参数匹配失败。
	* 若形式参数是不等于 `#ignore` 的符号，则尝试绑定操作数到以符号确定的名称的形式参数。
		* 若符号以一个*标记字符(sigil)* 起始，则被绑定的变量名中去除此前缀。
		* 若去除前缀得到的符号为空，则忽略操作数，不绑定对象。
	* 否则，忽略操作数，不绑定对象。

　　其中，标记字符是字符 `&`、`%` 和 `@` 之一。标记字符影响引用相关的绑定，差异为：

* 没有标记字符生效时，对操作数按值绑定，实际参数值传递给对应的形式参数。
	* 若实际参数的值是泛左值，则实际参数上首先隐含左值到右值转换。
* 存在标记字符 `%` 或 `&` 时，按引用推断规则直接绑定或转发操作数。
	* 当实际参数是引用值时，隐含一次引用折叠。
* 存在标记字符 `@` 时，绑定以实际参数作为被引用对象的引用值，不论操作数的类型和值类别。
	* 初始化引用值时，没有引用折叠。

　　创建绑定时形式参数对应的变量被操作数初始化。形式参数中具有的前缀影响被绑定的变量的初始化方式。每个绑定符合以下规则。

* 若不存在绑定标记字符 `@` ，则：
	* 若操作数为可转移的对象的引用值，则被绑定对象是按以下规则初始化的蕴含隐含的引用折叠的引用值：
		* 存在标记字符时，使用引用推断规则，被绑定对象是操作数直接初始化的值，其中被绑定对象（引用值）的标签由操作数的（引用值）的标签决定：
			* 当有标记字符 `&` 、绑定非结尾列表且引用值的标签指定唯一引用时，被绑定对象（引用值）中包含绑定临时对象标签。
			* 否则，被绑定对象的标签和引用值的标签相同。
		* 否则，被绑定对象是操作数复制初始化（复制或转移）的值。
	* 否则，若操作数标签指定可修改的唯一引用或有标记字符 `%` 时的唯一引用，操作数是可转移的非引用值，被绑定的对象是临时对象。
	* 否则，当存在标记字符 `&` 时，被绑定对象是操作数的引用值。
	* 否则，被绑定对象是复制自操作数的值。
* 否则，被绑定的是操作数的引用：
	* 绑定操作数的引用时，要求引用的是列表中的项，否则抛出异常。
	* 被绑定的对象应是不唯一的值（直接绑定操作数右值以外的值），被绑定对象是操作数的引用值。

　　绑定结尾列表包含以下情形：

* 若绑定的列表是临时对象，则绑定子项复制消除，拆分新的列表对象作为被绑定对象；
* 否则，若存在标记字符 `&` ，则创建列表的子对象引用作为被绑定对象；
* 否则，创建新的列表，作为被绑定对象。

　　绑定结尾列表若创建列表（包括子对象引用隐含创建的共享列表对象），其中的子对象的元素是对应的操作数以对应的引用标记字符（若存在）绑定单一参数得到的值。

　　除绑定临时对象外，若绑定操作数的初始化的引用值时实际引用临时对象，则行为未定义。

**注释** 不和宿主语言一样可能延长右值类类型子对象的生存期。

　　当前不检查匹配的符号是否已经被绑定，形式参数树中重复的符号引起绑定的作用未指定。

　　创建的抽象作为操作子，被调用时：

* 保存当前环境作为动态环境。
* 创建环境*守卫(guard)* 保存当前环境，之后不论调用成功或出错都会回滚保存的环境。
* 创建新的环境，并以这个新环境作为当前环境。
* 若创建抽象时的 `<eformal>` 是不等于 `#ignore` 的符号则绑定动态环境（先前的当前环境）到这个以符号作为名称的变量。
* 设置操作子保存的静态环境为当前环境的父环境。
* 匹配实际参数。成功匹配时，其中绑定的对象初始化环境中的变量绑定。
* 以函数体（创建时以 `<body>` 指定）中的表达式的副本作为*求值结构(evaluation structure)* ，在当前环境进行求值。

　　类似 `$vau` ，但支持额外的求值环境作为静态环境。

　　因为支持保存环境的所有权，`$vau/e` 被设计为比 `$vau` 更基本的操作。

**注释** 不考虑所有权时，`eval` 和 `$vau` 可派生 $vau/e 。

`$vau/e% <parent> <formals> <eformal> <body>`

　　同 $vau/e ，但创建的操作子调用时保留 `<body>` 求值的引用值。

`wrap <combiner>`

　　包装合并子为应用子。

`unwrap <applicative>`

　　解包装应用子为底层合并子。

`raise-error <string>`

　　引起包含参数指定的字符串内容的错误。

**注释** 这里的错误是未归类的一般错误。

`raise-invalid-syntax-error <string>`

　　引起包含参数指定的字符串内容的语法错误。

`check-list-reference <object>`

　　检查对象是否是列表引用，若检查通过返回参数，否则引起类型检查错误。

`() make-encapsulation-type`

　　创建封装类型。

　　结果是三个合并子组成的列表，其元素分别表示用于构造封装类型对象的封装(encapsulate) 构造器、判断封装类型的谓词和用于解封装(decapsulate) 的访问器。

　　封装构造器保留参数中的引用值。

　　创建的封装类型的相等性（以 `eqv?` 判断）同被封装的对象。

**原理** 关于 API 的设计，参见 [RnRK] 8.1.1 。相等性判断的规则与之不同，以允许更好地支持和宿主语言中非特定对象类型的值之间的互操作。另见 [SRFI-137](https://srfi.schemers.org/srfi-137/srfi-137.html) 引用的关于[对唯一类型的讨论](https://small.r7rs.org/wiki/UniqueTypesSnellPym/)。

## 核心库函数

　　核心库函数在基础环境中直接提供绑定。

`() get-current-environment`

　　取当前环境：取当前环境的环境弱引用。

`() lock-current-environment`

　　锁定当前环境：取当前环境的环境强引用。

`$vau <formals> <eformal> <body>`

　　创建 vau 抽象。

　　类似 `$vau/e` ，但以当前环境代替额外的求值环境作为静态环境。

`$vau% <formals> <eformal> <body>`

　　创建 vau 抽象。

　　类似 `$vau/e%` ，但以当前环境代替额外的求值环境作为静态环境。

`id <object>`

　　结果为不隐含左值到右值转换的参数，在结果保留引用值。

　　其作用等价返回值转换，可能引起对象转移。

`idv <object>`

　　同 `id` ，但结果为返回值转换后的值。

**注释** 使用 `idv` 可指定在返回值中保留引用值的不安全操作的个别操作数不再保留引用值。

`list <object>...`

　　创建列表（类型为 `<list>` ）对象。

`list% <object>...`

　　创建列表（类型为 `<list>` ）对象，且保留参数中的引用值。

`$lvalue-identifier? <symbol>`

　　解析当前环境中的标识符（同 `$resolve-identifier` ）并判断是否为左值（同 `bound-lvalue?` ）。

`forward! <object>`

　　转发可能是引用的值。

　　参数是右值操作数或可修改的临时对象时转移，其它情形复制。

**注释** 被转发的值若是形式参数树中的变量，一般应以带有标记字符 `&` 的形式绑定；否则，转发的不是对应的实际参数，而可能是其按值绑定的副本。

`$remote-eval <expression> <environment>`

　　在动态环境求值第二参数得到的环境中求值第一参数，结果作为函数值。

`$remote-eval% <expression> <environment>`

　　同 `$remote-eval` ，但保留引用值。

`$set! <environment> <formals> <expressions>`

　　修改指定环境的变量绑定。

　　在当前环境求值 `<environment>` 和 `<expressions>` ，再以后者的求值结果修改前者的求值结果指定的环境中的绑定。绑定效果同使用 $def! 。

`$lambda <formals> <body>`

　　创建 λ 抽象 。

　　和创建 vau 抽象类似，但创建的是调用时对操作数的元素求值一次的应用子，且忽略动态环境。

　　表达式项的用法和 vau 抽象类似。

`$lambda% <formals> <body>`

　　同 `$lambda` ，但创建的操作子调用时保留 `<body>` 求值的引用值。

`$lambda/e <parent> <formals> <body>`

　　创建指定静态环境的 lambda 抽象。

　　类似 `$lambda` ，但支持显式指定的求值环境为静态环境。指定静态环境的参数含义同 `$vau/e` 。

`$lambda/e% <parent> <formals> <body>`

　　同 `$lambda/e` ，但保留引用值。

`$sequence <expression-sequence>`

　　顺序求值。操作数非空时结果是最后的参数，可能是引用值；否则结果是 `#inert` 。

　　求值每个 `<object>` 的副作用包括其中临时对象的销毁都被顺序限制。

`collapse <object>`

　　折叠可能是引用的值。

`assign%! <reference> <object>`

　　同 `assign@!` ，但 `<object>` 是引用值时赋值的源操作数是 `<object>` 折叠后的值。

`apply <applicative> <object> <environment>`

　　在指定环境中应用。

　　同求值 `eval (cons () (cons (unwrap <applicative>) <object>)) <environment>` 。

`apply <applicative> <object>`

　　在新环境中应用。

　　同求值 `eval (cons () (cons (unwrap <applicative>) <object>)) (() make-environment)` 。

　　以上 apply 的函数值保留引用值。

`list* <object>+`

　　在列表前附加元素创建列表。

　　类似 `cons` ，但支持一个和多个操作数。

　　对一个操作数的情形返回原值，否则类似 `cons` ，检查最后一个实际参数是 <list> 。

`list*% <object>+`

　　同 `list*` ，但创建的列表元素保留引用值。

`$defv! <variable> <formals> <eformal> <body>`

　　绑定 vau 抽象，等价 `$def! <variable> $vau <formals> <eformal> <body>` 。

`$defv%! <variable> <formals> <eformal> <body>`

　　绑定 vau 抽象，等价 `$def! <variable> $vau% <formals> <eformal> <body>` 。

`$defv/e%! <variable> <parent> <formals> <eformal> <body>`

　　绑定指定静态环境的 vau 抽象，等价 `$def! <variable> $vau/e% <parent> <formals> <eformal> <body>` 。

`$defw! <variable> <formals> <eformal> <body>`

　　绑定 `wrap` 的 vau 抽象，等价 `$def! <variable> wrap ($vau <formals> <eformal> <body>)` 。

`$defw%! <variable> <formals> <eformal> <body>`

　　绑定 `wrap` 的 `vau` 抽象，等价 `$def! <variable> wrap ($vau% <formals> <eformal> <body>)` 。

`$defl! <variable> <formals> <body>`

　　绑定 λ 抽象，等价 `$def! <variable> $lambda <formals> <body>` 。

`$defl%! <variable> <formals> <body>`

　　绑定 λ 抽象，等价 `$def! <variable> $lambda% <formals> <body>` 。

`$defl/e! <variable> <parent> <formals> <body>`

　　绑定指定静态环境的 λ 抽象，等价 `$def! <variable> $lambda/e <parent> <formals> <body>` 。

`$defl/e%! <variable> <parent> <formals> <body>`

　　绑定指定静态环境的 λ 抽象，等价 `$def! <variable> $lambda/e% <parent> <formals> <body>` 。

`forward-first% <applicative> <list>`

　　取列表的第一元素并转发给指定的应用子。

　　对参数列表 `(&appv (&x .))` ，作用同求值：

```
(forward! appv) (list% ($move-resolved! x))
```

　　其中，调用 `appv` 的底层合并子的当前环境同调用 `forward-first%` 的动态环境。

`first <list>`

　　取列表第一个元素的值。

　　当 `<list>` 是左值时结果是折叠的引用值，否则结果是返回值转换后的值。

`first% <list>`

　　同 `first` ，但结果总是转发的值。

　　转发的值是经过折叠但没有返回值转换的列表元素的值，无论参数是否为引用值。

`first& <list>`

　　同 `first` ，但结果总是折叠的引用值。

　　首先调用 `check-list-reference` 检查参数是列表引用，对右值抛出异常。

`rest <list>`

　　取列表第一个元素以外的元素值构成的列表。

`rest% <list>`

　　取列表第一个元素以外的元素值经过转发的值构成的列表。

`rest& <list>`

　　取列表第一个元素以外的元素值的引用值构成的列表的子对象引用。

　　首先调用 `check-list-reference` 检查参数是列表引用，对右值抛出异常。

`set-first%! <list> <object>`

　　修改列表的第一个元素，保留引用值。

`check-environment <object>`

　　检查环境。

　　若参数是 `<environment>` 则检查通过，结果是转发的参数；否则，引起错误。

　　检查环境通过的条件同创建合并子时的检查。

`$cond <clauses>...`

　　条件选择。

　　顺序求值 `<clause>` 中每个子项的 `<test>` ，以 `<test>` 求值结果作为条件，当条件成立时求值再求值对应的 `<body>` ，结果为求值 `<body>` 的结果。

`$when <test> <expression-sequence>`

　　条件成立时顺序求值。

　　求值 `<test>` ，结果作为条件，当条件成立时顺序求值 `<expression-sequence>` ，并以其求值结果作为调用的求值结果。

`$unless <test> <expression-sequence>`

　　条件不成立时顺序求值。

　　求值 `<test>` ，结果作为条件，当条件不成立时顺序求值 `<expression-sequence>` ，并以其求值结果作为调用的求值结果。

`$while <test> <expression-sequence>`

　　条件成立时循环求值。

　　循环求值 `<test>` ，结果作为条件，当条件成立时顺序求值 `<expression-sequence>` 。结果是最后一次 `<expression-sequence>` 求值（若存在）的求值结果。

`$until <test> <expression-sequence>`

　　条件不成立时循环求值。

　　循环求值 `<test>` ，结果作为条件，当条件不成立时顺序求值 `<expression-sequence>` 。结果是最后一次 `<expression-sequence>` 求值（若存在）的求值结果。

`not? <object>`

　　逻辑非。

　　若参数非 `#f` 时结果为 `#f` ，否则结果为 `#t` 。

`$and? <test>...`

　　逻辑与。

　　顺序短路求值。操作数为空时结果为 `#t` ；参数求值存在 `#f` 时结果为 `#f` ；否则结果为最后一个参数的值。

`$or? <test>...`

　　逻辑或。

　　顺序短路求值。操作数为空时结果为 `#f` ，参数求值存在不是 `#f` 的值时结果为第一个这样的值；否则结果为 `#t` 。

`accr <object1> <predicate> <object2> <applicative1> <applicative2> <applicative3>`

　　在抽象列表的元素上应用右结合的二元操作。

　　对 `<object1>` 指定的抽象列表进行处理，取得部分和。

　　当谓词 `<predicate>` 成立时结果为参数指定的对象，否则继续处理抽象列表中余下的元素。

　　处理抽象的列表的操作通过余下的应用子分别定义：取列表头、取列表尾和部分和的二元合并操作。

　　参数 `<applicative1>` 和参数参数 `<applicative2>` 应接受两个参数，否则引起错误。

　　参数 `<applicative3>` 应接受两个参数，否则引起错误。

　　调用参数中的应用子的 `<object1>` 实际参数在不同的应用子调用中可能同一。

　　调用参数中的应用子的底层合并子的当前环境同调用 `accr` 的动态环境。

`foldr1 <applicative> <object> <list>`

　　作用同符合以下要求的 `accr` 调用：

* 指定 `accr` 的参数为 `<list>` 、`null?` 、`(forward! <object>)` 、`first%` 、`rest%` 和 `<applicative>` ；
* 调用应用子 `rest%` 时不复制 `<object>` 或其子对象。

　　参数指定的应用子的调用不添加或移除列表元素，否则行为未定义。

**注释** 类似 [SRFI-1 的 `fold-right`](https://srfi.schemers.org/srfi-1/srfi-1.html#FoldUnfoldMap) ，但只接受一个真列表。

`map1 <applicative> <list>`

　　单列表映射操作，使用指定应用子对列表中每个参数进行调用，结果为调用结果的列表。

　　参数 `<applicative>` 应接受一个参数，否则引起错误。

　　操作中的应用子和列表构造的结果的确定满足过程调用的因果性；其余任意 `<applicative>` 调用的求值、列表构造操作和销毁列表中的元素的操作的相对顺序未指定。

**注释** `foldr1` 和 `map1` 名称中的 `1` 指 `<list>` 参数的个数。（更一般的其它形式可接受多个 `<list>` 。）

`list-concat <list1> <list2>`

　　取顺序连接的列表。

`append <list>...`

　　顺序拼接列表。

`filter <predicate> <list>`

　　在列表参数中选取经谓词判断非 `#f` 的元素的值的副本创建新的列表。创建的列表的元素的顺序和列表参数中的一致。

**注释** 调用谓词的求值顺序未指定。

`derive-current-environment <environment>...`

　　创建当前环境的派生环境。

　　创建参数指定的环境和当前环境作为父环境的空环境。

`() make-standard-environment`

　　创建*标准环境(standard environment)* ：以基础环境作为唯一父环境的新环境。

`$as-environment <body>`

　　求值表达式构造环境。

　　创建以动态环境为父环境的空环境，并在其中求值参数指定的表达式。

　　结果是创建的环境强引用。

`$let <bindings> <body>`

　　局部绑定求值：创建以当前环境为父环境的空环境，在其中添加 `<bindings>` 指定的变量绑定，再求值 `<body>` 。

`$let% <bindings> <body>`

　　同 `$let` ，但保留引用值。

`$let* <bindings> <body>`

　　顺序局部绑定求值。

　　同 `$let` ，但 `<bindings>` 中的被用于绑定的表达式从左到右顺序求值，被用于初始化变量的表达式在求值时可访问 `<bindings>` 中之前绑定的符号。

`$let*% <bindings> <body>`

　　同 `$let*` ，但保留引用值。

`$letrec <bindings> <body>`

　　顺序局部绑定求值，允许递归引用绑定。

`$bindings/p->environment (<environment>...) <binding>...`

　　转换绑定列表为以指定的环境列表中的环境为父环境的具有这些绑定的环境。

`$bindings->environment <binding>...`

　　转换绑定列表为没有父环境的具有这些绑定的环境。

`symbols->imports <symbol>...`

　　转换符号列表为未求值的适合初始化符号导入列表的初值符列表。

　　结果是包含同 `desigil` 的方式移除标记字符后的参数作为间接子项的列表。

　　求值这个列表，结果是同 `forward!` 的方式转发每个符号的列表，其元素顺序和 `<symbols>...` 中的值的顺序对应。

**注释** 结果通常作为指定从某个环境中存在的绑定的 `<defindend>` 。相对直接取符号列表，这支持移除引用标记字符和转发参数。

　　结果的结构和使用满足以下约定：

* 结果中可能存在合并子作为其子对象，其参数可能求值多次；
* 取结果中的子对象进行求值的行为未定义；
* 若结果被修改（如被转移），再求值时行为未定义；
* 若结果中的合并子在求值整个结果外的上下文被调用，行为未定义。

**注释** 以上约定可允许更有效的本机实现，不保证在实现中检查。

`$provide/let! <symbols> <bindings> <body>`

　　在当前环境中提供绑定：蕴含 `$let <bindings> <body>` ，在求值 `<body>` 后以结果作为操作数绑定到 `<symbols>` 的符号。

　　`<symbols>` 应能被作为 `<defindend>` 使用。

　　结果是对这些绑定具有所有权的环境强引用。

**注释** 绑定后的符号可通过作为 vau 抽象的父环境等形式依赖这个环境，因此用户需适当保存返回值使其生存期覆盖在被使用的绑定符号指称的对象生存期。

　　需要导入符号（即 `<symbols>...` 具有至少一个实际参数）时，以同 `symbols->imports` 的方式确定初值符。其中，等效的 `symbols->imports` 的求值次数未指定。

`$provide! <symbols> <body>`

　　求值第二参数并在当前环境绑定结果到第一参数指定的符号。

　　结果是带有这些绑定的环境。

　　需要导入符号时，以同 `symbols->imports` 的方式确定初值符。其中，等效的 `symbols->imports` 的求值次数未指定。

`$import! <environment> <symbols>`

　　从第一参数指定的环境导入第二参数指定的符号。

　　需要导入符号时，以同求值 symbols->imports 应用子的结果的方式确定初值符。其中，等效的 symbols->imports 的求值次数未指定。

## 代理求值

　　代理求值可支持以下求值得到的操作数：

* `<promise>` 求值代理：表示可被求值取得结果的对象。
	* 保存待求值的表达式和环境，或已求值的结果。

**注释** 在 `<promise>` 上的并发访问并不具有特别的同步保证和要求。

**原理** 代理求值的原语可实现[惰性求值](https://en.wikipedia.org/wiki/Lazy_evaluation)和透明的[记忆化](https://en.wikipedia.org/wiki/Memoization)求值。和一些流行的误解不同，尽管[原始设计](https://en.wikipedia.org/wiki/Futures_and_promises)是关于并行处理的，这不必然蕴含并发的[投机执行](https://en.wikipedia.org/wiki/Speculative_execution)，只是因为*解析(resolve)* 内部状态并不在用户程序中可见，而蕴含必要的最小同步。由于当前语言不支持并发访问，即使是对 `<promise>` 的修改操作导致变化，在语言中其状态也不可见，没有要求支持这种同步；未来可能会附加要求以提供更完善的并发支持。关于 API 的设计，参见 [RnRK] 9 和 [SRFI-45](https://srfi.schemers.org/srfi-45/) 。
	
`promise? <object>`

　　判断参数是否为 <promise> 类型的值。

`memoize <object>`

　　记忆化求值：以参数作为已被求值的结果创建 `<promise>` 对象。

　　在结果中保留参数的引用值。

`$lazy <body>`

　　延迟求值：以参数为待求值的表达式，以当前环境作为这个表达式被求值的动态环境，创建 `<promise>` 对象。

`$lazy% <body>`

　　同 `$lazy` ，但保留引用值。

`$lazy/d <environment> <body>`

　　同 `$lazy` ，但以参数指定环境替代动态环境。

`$lazy/d% <environment> <body>`

　　同 `$lazy%` ，但以参数指定环境替代动态环境。

`force <promise>`

　　立即求值指定的 `<promise>` 对象。

　　若参数在求值时修改为非 `<promise>` 类型的对象，需要继续迭代求值时，引起类型错误。

**注释** 通过 `force` 引起 `<promise>` 对象的求值可能蕴含修改这个对象而使其中的状态失效的操作（如通过 `assign!` ）。因此，实现中需要重新访问状态，而重新进行类型检查。

## 字符串操作

　　字符串操作加载为基础环境下的 `std.string` 环境。

　　字符串操作支持以下求值得到的操作数：

* `<regex>` 正则表达式类型。

`++ <string>...`

　　字符串串接。

`string-empty? <string>`

　　判断字符串是否为空。
　　
`string<- <string1> <string2>`

　　字符串赋值。

　　以第二参数为源，修改第一参数指定的目标。

`string=? <string1> <string2>`

　　判断字符串是否相等。

`string-split <string1> <string2>`

　　取第二参数分隔第一参数得到的字符串的列表。

`string-contains? <string1> <string2>`

　　判断第一参数是否包含第二参数作为子串。

`string-contains-ci? <string1> <string2>`

　　判断第一参数是否包含第二参数作为子串，忽略大小写。

　　只在单字节字符集内的字符中区分大小写。

`string->symbol <string>`

　　转换字符串为符号。

`symbol->string <symbol>`

　　转换符号为字符串。

`string->regex <string>`

　　创建字符串初始化的正则表达式。

`regex-match? <string> <regex>`

　　在字符串中搜索正则表达式指定的模式串。

`regex-replace <string1> <regex> <string2>` 

　　替换字符串中的模式串，构造新字符串。

　　在 `<string1>` 的副本中搜索正则表达式指定的模式串的所有匹配，替换为 `<string2>` 指定的格式字符串。

　　结果是替换后的字符串。

## 算术操作

　　算术操作在基础环境中直接提供绑定。

　　算术操作可支持以下求值得到的操作数：

* `<int>` 整数类型。
* `<number>` 数值类型。当前是 `<int>` 类型。

**注释** `<int>` 对应 C++ 的 `int` 类型。未来可能添加和改变不同数值类型的支持。

`<? <number> <number>`

`<=? <number> <number>`

`>=? <number> <number>`

`>? <number> <number>`

　　数值关系操作，分别为：小于、小于等于、大于等于和大于。

　　结果为 \<bool> 类型的比较结果。

`+ <number>...`

`add2 <number> <number>`

　　加法。

　　参数是加数。

　　结果为 `<number>` 类型的和。

`- <number> <number>`

　　减法。

　　参数分别是被减数和减数。

　　结果为 `<number>` 类型的差。

`* <number>...`

`multiply2 <number> <number>`

　　乘法。

　　参数是乘数。

　　结果为 `<number>` 类型的积。

`div <int> <int>`

　　整除。

　　参数分别是被除数和除数。若第二参数等于 0 ，则引起错误。

　　结果为 `<int>` 类型的商。

`mod <int> <int>`

　　模。

　　参数分别是被除数和除数。若第二参数等于 0 ，则引起错误。

　　结果为 `<int>` 类型的余数。

## 标准 I/O 库

　　标准 I/O 库的操作加载为基础环境下的 `std.io` 环境。

`() newline`

　　输出换行。

`readable-file? <string>`

　　判断参数指定的文件名对应的文件是否存在且可读。

`load <string>`

　　加载参数指定的翻译单元。

　　当前实现中的参数为文件系统路径。

　　被加载的翻译单元视为对象的外部表示 ，经读取翻译为 Unilang 对象。

　　求值被加载后读取的对象，并以其求值结果作为表达式的求值结果。

`display <object>`

　　输出对象的外部表示。

## 系统库

　　系统库的操作加载为基础环境下的 `std.system` 环境。

`env-get <string>`

　　取宿主环境的环境变量字符串。

　　字符串参数指定环境变量的名称。

## 模块管理

　　模块管理操作加载为基础环境下的 `std.modules` 环境。

模块约定：

　　*需求字符串(requirement string)* 是具有 `<string>` 类型的非空字符串。

　　若操作的形式参数是需求字符串，实际参数是空字符串，则引起错误。

　　本模块共享可变状态以支持操作访问确定的模块字符串集合。

　　本模块隐含一个字符串序列作为需求字符串模板。

　　除非派生实现另行指定，需求字符串模板初始化后不可变。

　　需求字符串模板初始化的值由实现定义。

`registered-requirement? <string>`

　　判断参数是否是已在本模块注册的需求字符串。

`register-requirement! <string>`

　　在本模块注册参数为需求字符串。

`unregister-requirement! <string>`

　　在本模块注册解除参数为需求字符串。

`find-requirement-filename <string>`

　　查找需求字符串对应的文件名。

　　在需求字符串模板中顺序地搜索字符串，返回匹配字符串的结果。若不存在这样的结果，则引起错误。

　　判断需求字符串模板中的每一个字符串是否能被需求字符串匹配时，首先替换字符串中的单字符子串 "?" 为需求字符串，取得替换结果，再判断它是否为可读的文件的文件名。

　　替换字符串时，每一个子串被同时一次替换；不对替换结果进一步递归地替换。

`require <string>`

　　按需加载需求字符串对应的模块。

　　若参数指定的需求字符串没有注册，则注册需求字符串并加载同调用 `find-requirement-filename` 等价的方式搜索得到的结果；否则没有作用。

## 辅助标准库功能

　　包含当前设计中未归类的以标准库提供的辅助运行时功能。

`random.choice <list>`

　　若参数非空，随机选择其元素作为结果；否则引起错误。

## 系统互操作

　　系统互操作包含和外部实现环境交互的操作。

　　使用的类型参见[算术操作](#算术操作)。

`sys.exit <int>`

　　以指定返回值退出进程。相当于调用 C++ 标准库的 `std::exit` 。

## 外部语言交互接口

　　外部语言交互接口是支持系统交互的底层 API ，主要以外部函数接口(FFI, foreign function interface) 的形式体现，支持调用 C 语言和兼容二进制实现的动态库中的函数。

　　外部语言交互支持以下求值得到的操作数：

* `<ffi-library>` FFI 库对象，表示一个适用外部语言交互的动态库的对象。
* `<ffi-call-interface>` FFI 调用接口对象，描述使用 FFI 调用函数需要的参数和返回类型信息。

　　系统互操作在基础环境中直接提供绑定。

`ffi-library? <object>`

　　判断参数是否为 `<ffi-library>` 对象的类型谓词。

`ffi-load-library <string>`

　　从参数指定的外部位置加载动态库。求值的结果是表示加载的动态库的 `<ffi-library>` 对象。

`ffi-call-interface? <object>`

　　判断参数是否为 `<ffi-call-interface>` 对象的类型谓词。

`ffi-make-call-interface <string1> <string2> <list>`

　　创建 FFI 调用接口。

　　参数分别为表示 ABI 的字符串、表示返回类型的字符串和一个表示函数参数类型的字符串的列表。

　　当前支持的 ABI 应为 `"FFI_DEFAULT_ABI"` 。

　　支持的类型表示如下：

* `"string"` 以指针编码的 C 字符串。对应语言内的 `string` 类型。
* `"void"` 仅用于返回值类型 `void` 。
* `"sint"` 类型 `int` 。
* `"sint"` 类型 `int` 。
* `"pointer"` 以 `void*` 编码的对象指针类型。
* `"uint8"` 类型 `uint8_t` 。
* `"sint8"` 类型 `int8_t` 。
* `"uint16"` 类型 `uint16_t` 。
* `"sint16"` 类型 `int16_t` 。
* `"uint32"` 类型 `uint32_t` 。
* `"sint32"` 类型 `int32_t` 。
* `"float"` 类型 `float` 。
* `"double"` 类型 `double` 。

`ffi-make-applicative <ffi-library> <string> <ffi-call-interface>`

　　创建以 FFI 调用 C 函数的应用子。

　　参数指定 FFI 库、函数名称和 FFI 调用接口。

　　不支持 C 函数的可变参数。

`ffi-make-callback <applicative> <ffi-call-interface>`

　　创建 FFI 回调函数对象。

# 初始化

　　用户程序使用的初始环境包括以下初始化：

* 确保基础环境可用，并创建以基础环境为父环境的空环境。
* 用户环境初始化。

　　之后，运行用户程序。

　　其中，用户环境初始化的默认行为等效以下操作：

* 在当前环境中引入标准 I/O 库的操作：
	* `newline`
	* `load`
	* `display`

　　实现可提供其它形式的、由实现定义的用户环境初始化操作替代上述的默认用户环境初始化。

